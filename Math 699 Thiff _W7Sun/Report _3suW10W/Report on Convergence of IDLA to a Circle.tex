%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 8/22 _3suW10W
% 8/28 _3suW11T
% 8/29 _3suW11W

\documentclass[letterpaper]{article}
\usepackage[paperwidth=8.5in, paperheight=11in]{geometry}
\linespread{1.0}
\normalsize

\usepackage[utf8]{inputenc}

\usepackage{indentfirst}
\usepackage[utf8]{inputenc}
\usepackage{geometry}

\usepackage{amsmath,amsfonts,amsthm} % Math packages
\newcommand{\thickhat}[1]{\mathbf{\hat{\text{$#1$}}}}
\newcommand{\thickbar}[1]{\mathbf{\bar{\text{$#1$}}}}
\newcommand{\thicktilde}[1]{\mathbf{\tilde{\text{$#1$}}}}

\usepackage[english]{babel}
\usepackage[autostyle]{csquotes}

%\usepackage{spverbatim}

\usepackage{listings}
\usepackage{lstautogobble}

\lstset{basicstyle=\ttfamily,
	mathescape=true,
	escapeinside=||,
	autogobble,
	xleftmargin=0.7in,
	xrightmargin=.25in}

\usepackage{graphicx}

\usepackage[export]{adjustbox}

\usepackage{amsfonts} % if you want blackboard bold symbols e.g. for real numbers

\usepackage{amsmath}
\usepackage{chngcntr}
\usepackage{wrapfig}
\usepackage{caption}
\usepackage{subcaption}

%\usepackage{subfig}




\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\title{	
	\normalfont \normalsize 
	\huge The Convergence of IDLA to a Circle \\ % The assignment title
}

\author{Jean-Luc Thiffeault and Ruojun Wang} % Your name

\date{\normalsize\today} % Today's date or a custom date

\begin{document}
	
\maketitle % Print the title
	

\section{An IDLA Simulation and the Boundary}

\subsection{An IDLA Simulation with N Particles}

Internal diffusion-limited aggregation (IDLA) is a cluster growth process in which particles start at one or more sources within a cluster, diffuse outward, and are added to the cluster at the first site outside it they reach. In this section, I summarize how the codes I was given simulate an IDLA process, and how I modify them to see a slightly different IDLA process.

\subsubsection{Particles move in 8 directions}
I started from  MATLAB codes given by Professor Thiffeault. To beign, a grid quadrant centered at the origin $(0,0)$ (written as $(0,0)$ in MATLAB codes) is prepared based on the total number of particles $N_{part}$ (written as \texttt{Npart} in MATLAB codes) which involve in the process. The area of the quadrant equals to $[ceil(1.2\sqrt{N_{part}})]^2$, where $ceil$ rounds a number up to its closest integer. At the origin, the particles are added to the process one by one. The $j^{th}$ (where $0 \leq j \leq N_{part}$) particle settles down at the origin; then the $(j+1)^{th}$ particle have to move to the next unoccupied grid. It chooses a random direction to move along generated by \texttt{(randi(3,1,2)-2)}: 2 horizontal directions, 2 vertical directions, and four diagonal directions. An occupied grid would be marked as "1" then. The results of the simulation are shown in Figure 1.1. We can observe that with the growth of the number of particles participating in the IDLA process, the boundary of the occupied region tends to imitate a circle.

\begin{figure}[htbp]
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{8direct_Npart100_3suW11T}
		\caption{\texttt{Npart = 100}}
		\label{8direct_Npart100_3suW11T}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{8direct_Npart1000_3suW11T}
		\caption{\texttt{Npart = 1000}}
		\label{8direct_Npart1000_3suW11T}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{8direct_Npart10000_3suW11T}
		\caption{\texttt{Npart = 10000}}
		\label{8direct_Npart10000_3suW11T}
	\end{subfigure}
	\caption{IDLA simulation with 8 directions}
	\label{IDLA simulation with 8 directions}
\end{figure}
	



\subsubsection{Particles move in 4 directions}
My first task is to make particles move in 4 directions randomly rather than in 8 directions and to see if the final shape of the occupied region still converges to a circle. The diagonal motion of particles (i.e. upper left, upper right, lower left, lower right) are eliminated in this case. In MATLAB codes, we prepare a $4*2$ matrix containing 4 vectors including four directions that a particle can move along. Then similarly as the process with 8 possible directions in the previous section, inside the for loop, we start from the center of the grid quadrant \texttt{[0 0]}. After determining a random number inside a list consisting 1 to 4, we are able to select a vector in the $4*2$ matrix and then determine the direction of the particle moves along. The results of the simulation are shown in Figure 1.2. We could then observe that an IDLA simulation generates an occupied region which converges to a circle, as the number of particles which participate in the process increases (Figure 1.2).

\begin{figure}[htbp]
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{4direct_Npart100_3suW11T}
		\caption{\texttt{Npart = 100}}
		\label{4direct_Npart100_3suW11T}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{4direct_Npart1000_3suW11T}
		\caption{\texttt{Npart = 1000}}
		\label{4direct_Npart1000_3suW11T}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{4direct_Npart10000_3suW11T}
		\caption{\texttt{Npart = 10000}}
		\label{4direct_Npart10000_3suW11T}
	\end{subfigure}
	\caption{IDLA simulation with 4 directions}
	\label{IDLA simulation with 4 directions}
\end{figure}


\subsection{Boundary of the Occupied Region}
Next, we select out the pixels which constitute the boundary of the occupied region, denoted as $(p_i)_{0 \leq i \leq N-1}=(m_i,n_i)_{0 \leq i \leq N-1}$, where $N$ is the total particle numbers on the boundary. By studying these pixels, we might understand to what extent the final occupied region converges to a cirlce. Three different algorithms are designed to give the boundary only as the IDLA process evolves. 

\subsubsection{Three Algorithms to Build the Boundary}

\paragraph{Build entire boundary.}
We start by examining an occupied grid $p_i$ on the boundary (for example, one on the boundary which has the same horizontal coordinate as the center grid). Then by checking its neighbor occupied grids, we choose the next grid $p_{i+1}$ which locates on the boundary. By examining all neighbors of $p_{i+1}$ and keep determining the next grid, we find all the grids on the boundary of the occupied region. If an occupied grid is marked as "1" and an unoccupied one is marked as "0," we can determine the next occupied grid on the boundary by seeing if all its horizontally and vertically connected neighbors are marked as "1." The result is shown in Figure 1.4(a).

\paragraph{Build boundary incrementally.} 
This algorithm is designed to check all the grids on the grid quadrant and select out the grids which construct the boundary only as the occupied region grows. A method is used to tell the difference between the grids inside the region and outside it: the grids which are not on the boundary are surrounded by grids along its four sides, while the grids which are on the boundary have at least one side which does not touch another grid. Hence, as one more particle is added to the process, we could eliminate those which are not considered on the boundary. For example, in Figure 1.3, when the fifth particle is added to the process, we can determine the grid at the center is no longer a grid on the boundary and it should be removed. As the previous algorithm, the grids which are occupied are marked as "1," and those which are not occupied are denoted as "0." By examining if all four neighbors of one grid are marked as "1," we are able to determine whether one grid is considered on the boundary. Figure 1.4(b) demonstrates The final shape of the boundary.

\begin{figure}[h]
		\centering
		\includegraphics[width=0.7\linewidth]{bdryAlg2}
		\caption{Build boundary incrementally: When the fifth particle is added to the process, a grid which is not on the boundary is then appears and needs to be removed.}
		\label{fig:bdryAlg2}
\end{figure}

\paragraph{Build boundary by Discrete Laplace (Figure 1.4(c)).}
The third algorithm using Discrete Laplace has the similar idea to the second one. A Discrete Laplace can be written as:

\begin{align} 
(\Delta f)_{i,j} = 4f_{i,j}-f_{i+1,j}- f_{i-1,j}-f_{i,j+1}-f_{i,j-1},
\end{align}

\noindent
where $i$ and $j$ here represent the horizontal and vertical coordinate of the center of one grid. Similarly to the second algorithm, the grids which are occupied are marked as "1," and those which are not occupied are denoted as "0." Hence, if $(\Delta f)_{i,j}>0$, the grid with coordinate $(i,j)$ is considered on the boundary. 

\paragraph{Compare boundaries given by 3 algorithms.}
In order to see if those three algorithms return the same results regarding the grids on the boundary which are selected out, I also further compare the discretized boundary generated by three algorithms and it turns out they agree with each other.


\begin{figure}[htbp]
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{3bdry1}
		\caption{Build entire boundary.}
		\label{3bdry1}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{3bdry2}
		\caption{Build boundary incrementally.}
		\label{3bdry2}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{3bdry3}
		\caption{Build boundary by Discrete Laplace.}
		\label{3bdry3}
	\end{subfigure}
	\caption{Boundary of the occupied region resulted by IDLA process.}
	\label{3bdry}
\end{figure}



\subsubsection{The Numerical Standard Deviation}
We compute a numerical average distance $\overline{D_j}$ (where $0 \leq j \leq N_{part}$) based on the distance between the center of each grid on the boundary and the center of the grid quadrant, as each time one more particle is added to the process, where $j$ denotes the particle number added in the process. This distance $\overline{D_j}$ can be roughly considered as the radius of a circle $O$, if we could obtain such an $O$ when the number of particles participating in the IDLA process $N_{part} \rightarrow \infty$. From Figure 1.5, we see that $\overline{D_j}$ and $j$ are roughly linearly related. We further compute the standard deviation $\sigma_j$, with respect to the particle number $j$ added to the process. The relation of $\sigma_j$ versus $j$ can also be plotted by MATLAB (Figure 1.5). When $N_{part}=10000$, $\sigma_j=0.72172$. If the occupied region generated by IDLA process converges to a circle as we expected previously, $\sigma_j$ should be also converging as a smooth function with respect to a large $N_{part}$; however, it is hard to see if $\sigma_j$ converges from the plot. 

We denote this $\sigma_j$ as $\sigma_{sim}$, saying that this is the standard deviation given by the whole simulation. It consists of two different errors, the geometric error $\sigma_{geom}$ and the statistical error $\sigma_{stat}$. We would first look at the the geometric error $\sigma_{geom}$, since it helps us understand how much error would be generated even if we draw a perfect circle on a grid quadrant.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\linewidth]{bdryRandSTD}
	\caption{Average distance versus particle numbers and standard deviation versus particle numbers when \texttt{Npart=10000}.}
	\label{fig:bdryRandSTD}
\end{figure}








\section{The Geometric Error}

The basic setup is given by Professor Thiffeault's handout \enquote{On Discretizing a Circle}. We consider a grid (a lattice of circle) in the plane with centers at coordinates $p=(m, n)\in\mathbb{Z}^2$. The center of circle drawn locates at the origin $(0,0)$. Take a circle of radius $R$, centered on the origin. A continuous discretization of the circle is an ordered set of distinct pixels 

\begin{align} 
\mathcal{D}_R=(p_{i})_{0 \leq i \leq N-1} = (m_i, n_i)_{0 \leq i \leq N-1},
\end{align}

\noindent
where $m_i$ denotes the horizontal coordinate of the center of a pixel and $n_i$ denotes the vertical one of that. There are two different ways to construct such a discretized circle by coding. For convenience, we call them \enquote{non-remove} case and \enquote{remove} case.


\subsection{Two Types of Discretized Circle and Their Numerical Standard Deviation}

\subsubsection{The \enquote{Non-remove} Case}


In a "non-remove" case, the pixels $p_i$ is just those which the boundary of the circle centered at $(0,0)$ passes through. The resulted boundary consists of the grids connected horizontally, vertically, and diagonally (Figure 2.1). 

\begin{figure}[htbp]
	\centering
	\begin{subfigure}[b]{0.2\textwidth}
		\includegraphics[width=\textwidth]{NonrmvSetup}
		\caption{The \enquote{non-remove} case.}
		\label{NonrmvSetup}
	\end{subfigure}
	\begin{subfigure}[b]{0.2\textwidth}
		\includegraphics[width=\textwidth]{RmvSetup}
		\caption{The \enquote{remove} case.}
		\label{RmvSetup}
	\end{subfigure}

	\caption{Construct the discretized boundary of \enquote{non-remove} and \enquote{remove} cases}
	\label{Construct the discretized boundary of "non-remove" and "remove" cases}
\end{figure}

The algorithm can also be realized by MATLAB codes. The main idea is to start from a grid on the boundary, and to examine its neighbors and to determine the next grid which could be used to construct the boundary of a circle. We only consider grids for the upper right quarter of the circle; other three discretized quarters would just be the mirror images of the upper right one respect to the horizontal or vertical axises in the center. The final constructed circle is shown in Figure 2.2. We can then compute a numerical standard deviation $\sigma_{geom}$. As an example, given $R=10000$, $\sigma_{geom}=0.3729$.

\begin{figure}[htbp]
	\centering
	\begin{subfigure}[b]{1\textwidth}
		\includegraphics[width=\textwidth]{NonrmvCircle}
		\caption{A \enquote{non-remove} circle.}
		\label{NonrmvCircle}
	\end{subfigure}
	\begin{subfigure}[b]{1\textwidth}
		\includegraphics[width=\textwidth]{NonrmvCircleZI}
		\caption{A \enquote{non-remove} circle with $\times 10^4$ zoom in.}
		\label{NonrmvCircleZI}
	\end{subfigure}

	\caption{A \enquote{non-remove} circle, its $\times 10^4$ zoom in. Circle gridpoints rather than square colored grids are used to raise the computation speed. }
	\label{circle and zoom in}
\end{figure}


	
\subsubsection{The \enquote{Remove} Case}

Another ways to construct a discretized consisting of less pixels on the boundary than those in the first algorithm: The boundary of the cirlce might or might not pass through each pixel, but no grids on the boundary can have more than one horizontally or vertical neighbors.

The algorithm can be realized by MATLAB codes: The main procedures are similar to those for a \enquote{non-remove} circle; when we examine neighbors of one particular grid, we only remain the neighbor whose center is closest to the boundary of the circle which passes through (Figure 2.3). The numerical standard deviation can be computed: When $R=10000$, $\sigma_{geom}=0.2624$, which is smaller than the value obtained from the first algorithm.


\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{rmvCircleZI}
	\caption{A \enquote{remove} circle's $\times 10^4$ zoom in.}
	\label{rmvCircleZI}
\end{figure}

\subsection{The Upper Bound of $L_{2}$ Error of the Discretization}

A derivation of $L_{2}$ Error of the discretization is provided by Professor Thiffeault's handout "On Discretizing a Circle". Once we have $\mathcal{D}_R=(p_{i})_{0 \leq i \leq N-1} = (m_i, n_i)_{0 \leq i \leq N-1}$, we define the average radius of $\mathcal{D}_R$ as


\begin{align} 
\text{Rad} \ \mathcal{D}_R=\frac{1}{N} \sum_{i=0}^{N-1} (m_i^2+n_i^2)^{\frac{1}{2}}.
\end{align}

\noindent
In order for a discretization to be valid, it must converge to the circle in the limit as $R \rightarrow \infty$: 

\begin{align} 
\lim_{R \rightarrow \infty} \ \text{Rad} \ \mathcal{D}_R = R.
\end{align}

\noindent
The $L^2$ error can then be written as 

\begin{align} 
\text{Err}_2 \ \mathcal{D}_R=(\frac{1}{N} \sum_{i=0}^{N-1} (m_i^2+n_i^2)-R^2)^{\frac{1}{2}}.
\end{align}


We define a $D_{x,y}$, where $x$ is horizontal coordinate and $y$ is the vertical one. The distance between the center of the circle $O$ and the center of each grid is just $D_{m_i,n_i}$ (simply as $D_{m,n}$ then). $\text{Err}_2 \ \mathcal{D}_R$ is just the distance between the boundary of the circle and the center of each grid $(m_i,n_i)$ (simply as $(m,n)$ then); we could denote it as $d$ and $d=|D_{m,n}-R|$. We can compute an average distance $\overline{D_i}$ as we compute $\overline{D_j}$ for the IDLA boundary. When $R$ is large, $\overline{D_i} \approx R$ and 

\begin{align}
\sigma_{geom} \approx d = |D_{m,n}-R|. 
\end{align}


We can then estimate the geometric error by studying the distance $d$. We also denote a small piece of the boundary passing through each circle as $c_i$. As $R \rightarrow \infty$, $c_i$ could be just a segment rather than an arc of the circle. Assume that this piece $c_i$ is randomly distributed in each grid; we could then compute the expectation value $\mathbb{E}\ d^2$: Suppose a small region inside a grid with area $dx \times dy$ such that $x$ represents the horizontal coordinate and $y$ represents the vertical one. The probability density function $p(x,y)$ is then given by

\begin{align} 
p(x,y)=\frac{1}{A}=1
\end{align}

\noindent
where $A$ represents the area of one grid and $A=1$. $p(x,y)$ should also fulfill $\int_{0}^{1}\int_{0}^{1}p(x,y) \ dx \ dy=1$. Also, with 

\begin{align} 
d^2=(x-\frac{1}{2})^2+(x-\frac{1}{2})^2,
\end{align}

\noindent
the expectation value of $d^2$ is then

\begin{align} 
\mathbb{E}(d^2) = \int_{0}^{1} \int_{0}^{1}f(x,y) \ p(x,y) \ dx \ dy = 2 \  \mathbb{E}(x-\frac{1}{2})^2 = 2 \int_{0}^{1}(x-\frac{1}{2})^2 \cdot 1 \ dx = \frac{1}{6}.
\end{align}

\noindent
Thus, if the small piece $c_i$ is randomly distributed, the expectation value $\mathbb{E}\ d^2 \approx 0.1667$. 

For both \enquote{non-remove} and \enquote{remove} cases, an upper bound can be found for $d^2$, which approximately equal to $\sigma_{geom}^2$ when $R \rightarrow \infty$. For now, by observation, $\sigma_{geom}^2 \leq \frac{1}{2} \approx 0.5$ and then $\sigma_{geom} \leq 0.7071$, since the largest possible $d^2$ equals to $\frac{1}{2}$. Our next task is to find a smaller upper bound for  $\sigma_{geom}$ and obtain a new bound which is as close to $0.1667$ as possible. We firstly sort pixels into 4 different types as following to lower the upper bound of $d^2$.

\subsubsection{Sort Pixels into 4 Different Types}
According to the ways that the boundary of the circle passes through each pixel, we can sort $N$ pixels into 4 different types for the upper right quarter of the circle (other three quarters would just be the mirror images of the upper right one with respect to different axises of symmetry). As the algorithm provided above, the center of each pixel is represented by $(m_i, n_i)$. The boundary of the circle passing by would have 2 different intersections with a pixel $p_i$ (Figure 2.4). Hence, the four different type of grids can be given by the inequalities restricting the coordinates $(x,y)$ of the intersections. For example, the intersection point A in the first kind of pixel is provided by  

\begin{align} 
x=m_i-\frac{1}{2}; \ n_i-\frac{1}{2}\leq y \leq n_i-\frac{1}{2}, \ \text{where} \ y=\sqrt{R^2-(m_i-\frac{1}{2})^2};
\end{align}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth]{4ty}
	\caption{Sort pixels into 4 different types}
	\label{fig:4ty}
\end{figure}

\noindent
Other similar inequalities can be written to represent other types of pixels. We guess that these four different types of pixels might hold different upper bounds of $L^2$ error. Hence, by weighing four different values of upper bound correctly with respect to the fractions of these types of pixels, we might be able to obtain a smaller upper bound for $\sigma_{geom}$. With MATLAB codes, when $R=10000$, the numerical fraction of the four different type of pixels in the first quarter for a "non-remove" case are 

\begin{align} 
\text{fraction of type 1}=0.29291; \\
\text{fraction of type 2}=0.29286; \\
\text{fraction of type 3}=0.20711; \\
\text{fraction of type 4}=0.20711; 
\end{align}

\noindent
For a "remove" case, this would be
\begin{align} 
\text{fraction of type 1}=0.20522; \\
\text{fraction of type 2}=0.20897; \\
\text{fraction of type 3}=0.29291; \\
\text{fraction of type 4}=0.29291; 
\end{align}

\paragraph{A derivation for upper bound of the error.}
Let $D_{m,n}$ denote the distance between the center of the circle and the center of one pixel (corresponding to $\overline{D_j}$ defined in IDLA process); $R$ is the radius of the circle (Figure 2.5). Then 

\begin{align} 
|D_{m,n}-R| \leq \frac{1}{\sqrt{2}}.
\end{align}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth]{4tyDeri}
	\caption{Inequalities for each intersection can be written based on the geometry.}
	\label{fig:4tyDeri}
\end{figure}


\noindent
The inequalities satisfied by each type of pixels can also be written down in terms of a relation between radius $R$ and the distance $D_{x,y}$ between the center of the circle and an intersection between the boundary of the circle and one corner of the pixel square. For the intersection point A in a type 1 pixel, we can write 

\begin{align} 
D_{m-\frac{1}{2},n-\frac{1}{2}} \leq R \leq D_{m-\frac{1}{2},n+\frac{1}{2}}
\end{align}

\noindent
If we just look at $D_{m-\frac{1}{2},n-\frac{1}{2}} \leq R$ and subtract its both sides by $D_{m,n}$

\begin{align} 
D_{m-\frac{1}{2},n-\frac{1}{2}} - D_{m,n} \leq R- D_{m,n},
\end{align}

\noindent
For the left hand side of the inequality, we can compute a general form of difference $D_{m+a,n+b} - D_{m,n}$ since it is more convenient to find all four inequalities with this form. Also, $m=D_{m,n}\cos \theta_{m,n}$ and $n=D_{m,n}\sin \theta_{m,n}$, substitute those two expressions into (2.12), we obtain

\begin{align}
\sqrt{(D_{m,n}\cos \theta_{m,n}+a)^2+(D_{m,n}\sin \theta_{m,n} +b)^2}-D_{m,n} \\
= D_{m,n}(\sqrt{1+\frac{2}{D_{m,n}}(a\cos \theta+b\sin \theta)+\frac{a^2+b^2}{D_{m,n}^2}}-1).
\end{align}

\noindent
By Taylor expansion, we have 

\begin{align} 
D_{m+a, n+b}-D_{m,n} = a\cos \theta +b\sin \theta + \mathcal{O}(Q^{-1}) \leq R-D_{m,n}.
\end{align}

\noindent
Hence, 
\begin{align} 
D_{m,n}-R \leq D_{m,n}-D_{m-\frac{1}{2},n-\frac{1}{2}} \leq \frac{1}{2}(\cos \theta_{m,n}+\sin \theta_{m,n})+\mathcal{O}(R^-1). \\
\Rightarrow \ -\frac{1}{\sqrt{2}R} \leq \frac{D_{m,n}}{R}-1 \leq \frac{1}{\sqrt{2}R}.
\end{align}

\noindent 
By the same procedures, we can obtain the inequality (2.16) with other three different $D(a,b)$. According to the definition of variance $\sigma^2$, we have 
\begin{align} 
\sigma_{m,n}^2 = \mathbb{E}[D_{m,n}^2-R^2].
\end{align}

\noindent
Square both sides of (2.25),

\begin{equation}
\frac{D_{m,n}^2}{R^2}-\frac{2\ D_{m,n}}{R}+1 \leq \frac{1}{2R^2} \\ \Rightarrow \frac{\mathbb{E}[D_{m,n}^2]}{R^2}-\frac{2\ \mathbb{E}[D_{m,n}]}{R}+1 \leq \frac{1}{2R^2} \\
\Rightarrow \frac{\mathbb{E}[D_{m,n}^2]}{R^2}-1 \leq \frac{1}{2R^2}. \\
\end{equation}

\noindent
Hence,
\begin{align}
d^2 \leq \frac{1}{2} \approx 0.5.
\end{align}

\noindent
Thus, approximately, $\sigma_{geom} \leq 0.7071$. The upper bound is still the same as we speculate previously. We need to find another method to get a smaller bound.

\subsubsection{An Observation of the Relation between the Fraction of Each Type of Pixels and Multiples of $R$}

This is an observation from examining the numerical values of a particular multiple of radius $R$ and the fraction of each type of pixels. The fraction of each type of pixels is listed in the previous section. We shall look at the geometry of a quarter itself. In Figure 2.6 segment $CD$ is perpendicular to segment $OA$, where $O$ is the center of the circle. We obtain $OD=\frac{R}{\sqrt{2}}$ and $AD=R(1-\frac{1}{\sqrt{2}}) \approx 0.29289R$, where $R$ is the radius of the circle.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.4\linewidth]{4tyMultR}
	\caption{The geometry of the upper right quarter and the first octant.}
	\label{fig:4tyMultR}
\end{figure}

\noindent
To construct the relation, we start by examining how each type of grids functions to help the boundary grows from $A$ to $C$. For a \enquote{non-remove} case, the vertically coordinate increases for each pixel; if $R$ is very large, the total increment is approximately $\frac{R}{\sqrt{2}}$. The horizontal coordinate decreases by $R(1-\frac{1}{\sqrt{2}})$ in total. We will only look at the pixels in the first octant since the second octant is just the mirror image of the first one; hence, we just need to consider type 1, 2, and 4, because type 3 would not appear in the first octant. The fractions ($R=10000$) for each type in the first octant are given by 
\begin{align} 
\text{fraction of type 1} = 0.2929;\\
\text{fraction of type 2} = 0.2929;\\
\text{fraction of type 4} = 0.4142;
\end{align}

\noindent
Type 1 and 4 result in vertical increments by 1 pixel; type 2 results in horizontal decrement by 1 pixel. Hence, in the first octant, 
\begin{align} 
\text{number of type 1 and 4}=\frac{R}{\sqrt{2}} \approx 0.70711R;\\
\text{number of type 2}=R(1-\frac{1}{\sqrt{2}}) \approx 0.29289R;
\end{align}

\noindent
Hence, when $R \rightarrow \infty$, multiples of $R$ help determine the fractions of each type of grids. 



For a \enquote{remove} case, from Figure 2.6, we observe that the numerical value represents segment AD might relate with the fraction of type 3 and 4 in a \enquote{remove} case given by (2.15) and (2.16). However, the same method used to derive a relation does not apply to a \enquote{remove} case, since now how each type of grids contributes to a particular increment or decrement is no longer clear. Thus, we need to sort grids in a more specific way. 



\subsubsection{Sort Pixels into 6 Different Types}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth]{6ty}
	\caption{Sort pixels into 6 different types.}
	\label{fig:6ty}
\end{figure}

Instead of just sorting pixels into 4 types, we sort those in the first octant into 6 types now, in order to examine more on their functions which cause increments and decrements (Figure 2.7). Thus, how each type of pixels causes increment or decrement is determined. If we denote the total horizontal decrement as $\Delta x$ and the total vertical increment as $\Delta y$, then

\begin{align} 
\Delta x \approx n_{1b}+n_{2a}+n_{2b}+n_{4b}; \\
\Delta y \approx n_{1b}+n_{1a}+n_{2b}+n_{4a}+n_{4b};
\end{align}

\noindent
where $n_{m}$ gives the number of one type of pixels shown in the first octant. As we show previously, $\Delta x=(1-\frac{1}{\sqrt{2}})R$ and $\Delta y=\frac{R}{\sqrt{2}}$. Substitute these two into the previous equations and simplify, we get

\begin{align} 
n_{4a}+n_{1a}-n_{2a} \approx (\sqrt{2}-1)R.
\end{align}

\noindent
To examine the number of type 4, we modify () by constructing a $n_{4a}+n_{4b}$ term on the left hand side

\begin{align} 
n_{4a}+n_{4b} \approx (\sqrt{2}-1)R+(n_{4b}-n_{1a})+n_{2a},
\end{align}

\noindent
where $n_{2a}=0$ for the first octant. Also, since every time a $4b$ type appears, a $1a$ type appears before it; similarly, when a $1a$ type shows, a $4b$ type also shows as its previous pixel. Hence, we have $n_{4b}-n_{1a}=0$. Then we just leave with $n_{4} \approx (\sqrt{2}-1)R$. The total grids in the first octant $n_{total}$ is just $\frac{2R}{\sqrt{2}}$. The fraction of type 4 in the upper right quarter is

\begin{align} 
\frac{n_{4}}{n_{total}} = \frac{(\sqrt{2}-1)R}{\frac{2R}{\sqrt{2}}} = 1-\frac{1}{\sqrt{2}}.
\end{align}

\noindent
Hence, when $R \rightarrow \infty$, fraction of type 4 is just $1-\frac{1}{\sqrt{2}}$. The upper bound of error of type 3 and 4 pixels is $\frac{1}{2}$. Let $p_x$ be the fraction for one kind of pixels; we can weigh a smaller upper bound of $d^2$ by 

\begin{equation}
d^2 \leq  \ p_1 \ (\frac{2}{\sqrt{2}})^2 + p_2 \ (\frac{2}{\sqrt{2}})^2 + p_3 \ (\frac{1}{2})^2 + p_4 \ (\frac{1}{2})^2 \\
 = (\sqrt{2}-1) \times (\frac{2}{\sqrt{2}})^2 + (1-\frac{1}{\sqrt{2}}) \times (\frac{1}{2})^2 + (1-\frac{1}{\sqrt{2}}) \times (\frac{1}{2})^2 \\
 \approx 0.25
\end{equation}

\noindent
Thus, approximately, an upper bound of geometric error $\sigma_{geom}^2 \leq 0.25$.


\end{document}